
#= none:1 =#
struct TKEDissipationVerticalDiffusivity{TD, KE, ST, LMIN, FT, DT} <: AbstractScalarDiffusivity{TD, VerticalFormulation, 2}
    #= none:2 =#
    tke_dissipation_equations::KE
    #= none:3 =#
    stability_functions::ST
    #= none:4 =#
    minimum_length_scale::LMIN
    #= none:5 =#
    maximum_tracer_diffusivity::FT
    #= none:6 =#
    maximum_tke_diffusivity::FT
    #= none:7 =#
    maximum_dissipation_diffusivity::FT
    #= none:8 =#
    maximum_viscosity::FT
    #= none:9 =#
    minimum_tke::FT
    #= none:10 =#
    minimum_stratification_number_safety_factor::FT
    #= none:11 =#
    negative_tke_damping_time_scale::FT
    #= none:12 =#
    tke_dissipation_time_step::DT
end
#= none:15 =#
function TKEDissipationVerticalDiffusivity{TD}(tke_dissipation_equations::KE, stability_functions::ST, minimum_length_scale::LMIN, maximum_tracer_diffusivity::FT, maximum_tke_diffusivity::FT, maximum_dissipation_diffusivity::FT, maximum_viscosity::FT, minimum_tke::FT, minimum_stratification_number_safety_factor::FT, negative_tke_damping_time_scale::FT, tke_dissipation_time_step::DT) where {TD, KE, ST, LMIN, FT, DT}
    #= none:15 =#
    #= none:27 =#
    return TKEDissipationVerticalDiffusivity{TD, KE, ST, LMIN, FT, DT}(tke_dissipation_equations, stability_functions, minimum_length_scale, maximum_tracer_diffusivity, maximum_tke_diffusivity, maximum_dissipation_diffusivity, maximum_viscosity, minimum_tke, minimum_stratification_number_safety_factor, negative_tke_damping_time_scale, tke_dissipation_time_step)
end
#= none:40 =#
TKEDissipationVerticalDiffusivity(FT::DataType; kw...) = begin
        #= none:40 =#
        TKEDissipationVerticalDiffusivity(VerticallyImplicitTimeDiscretization(), FT; kw...)
    end
#= none:43 =#
const TDVD{TD} = (TKEDissipationVerticalDiffusivity{TD} where TD)
#= none:44 =#
const TDVDArray{TD} = (AbstractArray{<:TDVD{TD}} where TD)
#= none:45 =#
const FlavorOfTD{TD} = (Union{TDVD{TD}, TDVDArray{TD}} where TD)
#= none:47 =#
#= none:47 =# @inline (Base.eltype(::TKEDissipationVerticalDiffusivity{<:Any, <:Any, <:Any, <:Any, FT}) where FT) = begin
            #= none:47 =#
            FT
        end
#= none:49 =#
#= none:49 =# Core.@doc "    TKEDissipationVerticalDiffusivity([time_discretization = VerticallyImplicitTimeDiscretization(),\n                                      FT = Float64;]\n                                      tke_dissipation_equations = TKEDissipationEquations(),\n                                      stability_functions = VariableStabilityFunctions(),\n                                      minimum_length_scale = StratifiedDisplacementScale(),\n                                      maximum_tracer_diffusivity = Inf,\n                                      maximum_tke_diffusivity = Inf,\n                                      maximum_dissipation_diffusivity = Inf,\n                                      maximum_viscosity = Inf,\n                                      minimum_tke = 1e-6,\n                                      minimum_stratification_number_safety_factor = 0.73,\n                                      negative_tke_damping_time_scale = 1minute,\n                                      tke_dissipation_time_step = nothing)\n\nReturn the `TKEDissipationVerticalDiffusivity` turbulence closure for vertical mixing by\nmicroscale ocean turbulence based on the prognostic evolution of two variables: the \nturbulent kinetic energy (TKE), and the turbulent kinetic energy dissipation.\nElsewhere this is referred to as \"k-ϵ\". For more information about k-ϵ, see\nBurchard and Bolding (2001), Umlauf and Buchard (2003), and Umlauf and Burchard (2005).\n\nArguments\n=========\n\n- `time_discretization`: Either `ExplicitTimeDiscretization()` or `VerticallyImplicitTimeDiscretization()`;\n                         default `VerticallyImplicitTimeDiscretization()`.\n\n- `FT`: Float type; default `Float64`.\n\n\nKeyword arguments\n=================\n\n- `maximum_diffusivity`: Maximum value for tracer, momentum, and TKE diffusivities.\n                         Used to clip the diffusivity when/if\n                         TKEDissipationVerticalDiffusivity predicts diffusivities\n                         that are too large.\n                         Default: `Inf`.\n\n- `minimum_tke`: Minimum value for the turbulent kinetic energy.\n                 Can be used to model the presence \"background\" TKE\n                 levels due to, for example, mixing by breaking internal waves.\n                 Default: 1e-9.\n\n- `negative_tke_damping_time_scale`: Damping time-scale for spurious negative values of TKE,\n                                     typically generated by oscillatory errors associated\n                                     with TKE advection.\n                                     Default: 1 minute.\n\nNote that for numerical stability, it is recommended to either have a relative short\n`negative_turbulent_kinetic_energy_damping_time_scale` or a reasonable\n`minimum_turbulent_kinetic_energy`, or both.\n" function TKEDissipationVerticalDiffusivity(time_discretization::TD = VerticallyImplicitTimeDiscretization(), FT = Float64; tke_dissipation_equations = TKEDissipationEquations(), stability_functions = VariableStabilityFunctions(), minimum_length_scale = StratifiedDisplacementScale(), maximum_tracer_diffusivity = Inf, maximum_tke_diffusivity = Inf, maximum_dissipation_diffusivity = Inf, maximum_viscosity = Inf, minimum_tke = 1.0e-6, minimum_stratification_number_safety_factor = 0.73, negative_tke_damping_time_scale = 1minute, tke_dissipation_time_step = nothing) where TD
        #= none:102 =#
        #= none:116 =#
        stability_functions = convert_eltype(FT, stability_functions)
        #= none:118 =#
        return TKEDissipationVerticalDiffusivity{TD}(tke_dissipation_equations, stability_functions, minimum_length_scale, convert(FT, maximum_tracer_diffusivity), convert(FT, maximum_tke_diffusivity), convert(FT, maximum_dissipation_diffusivity), convert(FT, maximum_viscosity), convert(FT, minimum_tke), convert(FT, minimum_stratification_number_safety_factor), convert(FT, negative_tke_damping_time_scale), tke_dissipation_time_step)
    end
#= none:131 =#
function with_tracers(tracer_names, closure::FlavorOfTD)
    #= none:131 =#
    #= none:132 =#
    :e ∈ tracer_names && :ϵ ∈ tracer_names || throw(ArgumentError("Tracers must contain :e and :ϵ to represent turbulent kinetic energy " * "for `TKEDissipationVerticalDiffusivity`."))
    #= none:136 =#
    return closure
end
#= none:143 =#
#= none:143 =# Base.@kwdef struct StratifiedDisplacementScale{FT}
        #= none:144 =#
        Cᴺ::FT = 0.75
        #= none:145 =#
        minimum_buoyancy_frequency::FT = 1.0e-14
    end
#= none:152 =#
function DiffusivityFields(grid, tracer_names, bcs, closure::FlavorOfTD)
    #= none:152 =#
    #= none:154 =#
    default_diffusivity_bcs = (κu = FieldBoundaryConditions(grid, (Center, Center, Face)), κc = FieldBoundaryConditions(grid, (Center, Center, Face)), κe = FieldBoundaryConditions(grid, (Center, Center, Face)), κϵ = FieldBoundaryConditions(grid, (Center, Center, Face)))
    #= none:159 =#
    bcs = merge(default_diffusivity_bcs, bcs)
    #= none:161 =#
    κu = ZFaceField(grid, boundary_conditions = bcs.κu)
    #= none:162 =#
    κc = ZFaceField(grid, boundary_conditions = bcs.κc)
    #= none:163 =#
    κe = ZFaceField(grid, boundary_conditions = bcs.κe)
    #= none:164 =#
    κϵ = ZFaceField(grid, boundary_conditions = bcs.κϵ)
    #= none:165 =#
    Le = CenterField(grid)
    #= none:166 =#
    Lϵ = CenterField(grid)
    #= none:170 =#
    u⁻ = XFaceField(grid)
    #= none:171 =#
    v⁻ = YFaceField(grid)
    #= none:172 =#
    previous_velocities = (; u = u⁻, v = v⁻)
    #= none:175 =#
    _tupled_tracer_diffusivities = Dict{Symbol, Any}((name => κc for name = tracer_names))
    #= none:176 =#
    _tupled_tracer_diffusivities[:e] = κe
    #= none:177 =#
    _tupled_tracer_diffusivities[:ϵ] = κϵ
    #= none:178 =#
    _tupled_tracer_diffusivities = NamedTuple((name => _tupled_tracer_diffusivities[name] for name = tracer_names))
    #= none:181 =#
    _tupled_implicit_linear_coefficients = Dict{Symbol, Any}((name => ZeroField() for name = tracer_names))
    #= none:182 =#
    _tupled_implicit_linear_coefficients[:e] = Le
    #= none:183 =#
    _tupled_implicit_linear_coefficients[:ϵ] = Lϵ
    #= none:184 =#
    _tupled_implicit_linear_coefficients = NamedTuple((name => _tupled_implicit_linear_coefficients[name] for name = tracer_names))
    #= none:187 =#
    return (; κu, κc, κe, κϵ, Le, Lϵ, previous_velocities, _tupled_tracer_diffusivities, _tupled_implicit_linear_coefficients)
end
#= none:191 =#
#= none:191 =# @inline viscosity_location(::FlavorOfTD) = begin
            #= none:191 =#
            (c, c, f)
        end
#= none:192 =#
#= none:192 =# @inline diffusivity_location(::FlavorOfTD) = begin
            #= none:192 =#
            (c, c, f)
        end
#= none:194 =#
function compute_diffusivities!(diffusivities, closure::FlavorOfTD, model; parameters = :xyz)
    #= none:194 =#
    #= none:196 =#
    arch = model.architecture
    #= none:197 =#
    grid = model.grid
    #= none:198 =#
    velocities = model.velocities
    #= none:199 =#
    tracers = model.tracers
    #= none:200 =#
    buoyancy = model.buoyancy
    #= none:201 =#
    clock = model.clock
    #= none:202 =#
    top_tracer_bcs = NamedTuple((c => (tracers[c]).boundary_conditions.top for c = propertynames(tracers)))
    #= none:204 =#
    if isfinite(model.clock.last_Δt)
        #= none:208 =#
        time_step_tke_dissipation_equations!(model)
    end
    #= none:212 =#
    (u, v, w) = model.velocities
    #= none:213 =#
    (u⁻, v⁻) = diffusivities.previous_velocities
    #= none:214 =#
    parent(u⁻) .= parent(u)
    #= none:215 =#
    parent(v⁻) .= parent(v)
    #= none:217 =#
    launch!(arch, grid, parameters, compute_TKEDissipation_diffusivities!, diffusivities, grid, closure, velocities, tracers, buoyancy)
    #= none:221 =#
    return nothing
end
#= none:224 =#
#= none:224 =# @kernel function compute_TKEDissipation_diffusivities!(diffusivities, grid, closure::FlavorOfTD, velocities, tracers, buoyancy)
        #= none:224 =#
        #= none:226 =#
        (i, j, k) = #= none:226 =# @index(Global, NTuple)
        #= none:229 =#
        closure_ij = getclosure(i, j, closure)
        #= none:233 =#
        κu★ = κuᶜᶜᶠ(i, j, k, grid, closure_ij, velocities, tracers, buoyancy)
        #= none:234 =#
        κc★ = κcᶜᶜᶠ(i, j, k, grid, closure_ij, velocities, tracers, buoyancy)
        #= none:235 =#
        κe★ = κeᶜᶜᶠ(i, j, k, grid, closure_ij, velocities, tracers, buoyancy)
        #= none:236 =#
        κϵ★ = κϵᶜᶜᶠ(i, j, k, grid, closure_ij, velocities, tracers, buoyancy)
        #= none:238 =#
        κu★ = mask_diffusivity(i, j, k, grid, κu★)
        #= none:239 =#
        κc★ = mask_diffusivity(i, j, k, grid, κc★)
        #= none:240 =#
        κe★ = mask_diffusivity(i, j, k, grid, κe★)
        #= none:241 =#
        κϵ★ = mask_diffusivity(i, j, k, grid, κϵ★)
        #= none:243 =#
        #= none:243 =# @inbounds begin
                #= none:244 =#
                diffusivities.κu[i, j, k] = κu★
                #= none:245 =#
                diffusivities.κc[i, j, k] = κc★
                #= none:246 =#
                diffusivities.κe[i, j, k] = κe★
                #= none:247 =#
                diffusivities.κϵ[i, j, k] = κϵ★
            end
    end
#= none:251 =#
#= none:251 =# @inline function turbulent_kinetic_energyᶜᶜᶜ(i, j, k, grid, closure, tracers)
        #= none:251 =#
        #= none:252 =#
        eᵐⁱⁿ = closure.minimum_tke
        #= none:253 =#
        eⁱʲᵏ = #= none:253 =# @inbounds(tracers.e[i, j, k])
        #= none:254 =#
        return max(eᵐⁱⁿ, eⁱʲᵏ)
    end
#= none:257 =#
#= none:257 =# @inline max_a_b(i, j, k, grid, a::Number, b, args...) = begin
            #= none:257 =#
            max(a, b(i, j, k, grid, args...))
        end
#= none:259 =#
#= none:259 =# @inline maximum_dissipation(i, j, k, grid, closure, tracers, buoyancy) = begin
            #= none:259 =#
            convert(eltype(grid), Inf)
        end
#= none:261 =#
#= none:261 =# @inline function minimum_dissipation(i, j, k, grid, closure, tracers, buoyancy)
        #= none:261 =#
        #= none:262 =#
        FT = eltype(grid)
        #= none:264 =#
        N²min = closure.minimum_length_scale.minimum_buoyancy_frequency
        #= none:265 =#
        N²⁺ = ℑbzᵃᵃᶜ(i, j, k, grid, max_a_b, N²min, ∂z_b, buoyancy, tracers)
        #= none:267 =#
        Cᴺ = closure.minimum_length_scale.Cᴺ
        #= none:268 =#
        e★ = turbulent_kinetic_energyᶜᶜᶜ(i, j, k, grid, closure, tracers)
        #= none:269 =#
        ℓst = Cᴺ * sqrt(e★ / N²⁺)
        #= none:271 =#
        𝕊u₀ = closure.stability_functions.𝕊u₀
        #= none:272 =#
        ℓmin = min(grid.Lz, ℓst)
        #= none:273 =#
        ϵmin = (𝕊u₀ ^ 3 * sqrt(e★) ^ 3) / ℓmin
        #= none:275 =#
        another_ϵmin = convert(FT, 1.0e-12)
        #= none:276 =#
        return max(another_ϵmin, ϵmin)
    end
#= none:279 =#
#= none:279 =# @inline function dissipationᶜᶜᶜ(i, j, k, grid, closure, tracers, buoyancy)
        #= none:279 =#
        #= none:280 =#
        ϵᵐⁱⁿ = minimum_dissipation(i, j, k, grid, closure, tracers, buoyancy)
        #= none:281 =#
        ϵᵐᵃˣ = maximum_dissipation(i, j, k, grid, closure, tracers, buoyancy)
        #= none:282 =#
        ϵⁱʲᵏ = #= none:282 =# @inbounds(tracers.ϵ[i, j, k])
        #= none:283 =#
        return clamp(ϵⁱʲᵏ, ϵᵐⁱⁿ, ϵᵐᵃˣ)
    end
#= none:286 =#
#= none:286 =# @inline function κuᶜᶜᶠ(i, j, k, grid, closure::TDVD, velocities, tracers, buoyancy)
        #= none:286 =#
        #= none:287 =#
        e² = ℑzᵃᵃᶠ(i, j, k, grid, ϕ², turbulent_kinetic_energyᶜᶜᶜ, closure, tracers)
        #= none:288 =#
        ϵ = ℑzᵃᵃᶠ(i, j, k, grid, dissipationᶜᶜᶜ, closure, tracers, buoyancy)
        #= none:289 =#
        𝕊u = momentum_stability_functionᶜᶜᶠ(i, j, k, grid, closure, velocities, tracers, buoyancy)
        #= none:290 =#
        κu = (𝕊u * e²) / ϵ
        #= none:291 =#
        κu_max = closure.maximum_viscosity
        #= none:292 =#
        return min(κu, κu_max)
    end
#= none:295 =#
#= none:295 =# @inline function κcᶜᶜᶠ(i, j, k, grid, closure::TDVD, velocities, tracers, buoyancy)
        #= none:295 =#
        #= none:296 =#
        e² = ℑzᵃᵃᶠ(i, j, k, grid, ϕ², turbulent_kinetic_energyᶜᶜᶜ, closure, tracers)
        #= none:297 =#
        ϵ = ℑzᵃᵃᶠ(i, j, k, grid, dissipationᶜᶜᶜ, closure, tracers, buoyancy)
        #= none:298 =#
        𝕊c = tracer_stability_functionᶜᶜᶠ(i, j, k, grid, closure, velocities, tracers, buoyancy)
        #= none:299 =#
        κc = (𝕊c * e²) / ϵ
        #= none:300 =#
        κc_max = closure.maximum_tracer_diffusivity
        #= none:301 =#
        return min(κc, κc_max)
    end
#= none:304 =#
#= none:304 =# @inline function κeᶜᶜᶠ(i, j, k, grid, closure::TDVD, velocities, tracers, buoyancy)
        #= none:304 =#
        #= none:305 =#
        e² = ℑzᵃᵃᶠ(i, j, k, grid, ϕ², turbulent_kinetic_energyᶜᶜᶜ, closure, tracers)
        #= none:306 =#
        ϵ = ℑzᵃᵃᶠ(i, j, k, grid, dissipationᶜᶜᶜ, closure, tracers, buoyancy)
        #= none:307 =#
        𝕊e = tke_stability_functionᶜᶜᶠ(i, j, k, grid, closure, velocities, tracers, buoyancy)
        #= none:308 =#
        κe = (𝕊e * e²) / ϵ
        #= none:309 =#
        κe_max = closure.maximum_tke_diffusivity
        #= none:310 =#
        return min(κe, κe_max)
    end
#= none:313 =#
#= none:313 =# @inline function κϵᶜᶜᶠ(i, j, k, grid, closure::TDVD, velocities, tracers, buoyancy)
        #= none:313 =#
        #= none:314 =#
        e² = ℑzᵃᵃᶠ(i, j, k, grid, ϕ², turbulent_kinetic_energyᶜᶜᶜ, closure, tracers)
        #= none:315 =#
        ϵ = ℑzᵃᵃᶠ(i, j, k, grid, dissipationᶜᶜᶜ, closure, tracers, buoyancy)
        #= none:316 =#
        𝕊ϵ = dissipation_stability_functionᶜᶜᶠ(i, j, k, grid, closure, velocities, tracers, buoyancy)
        #= none:317 =#
        κϵ = (𝕊ϵ * e²) / ϵ
        #= none:318 =#
        κϵ_max = closure.maximum_dissipation_diffusivity
        #= none:319 =#
        return min(κϵ, κϵ_max)
    end
#= none:322 =#
#= none:322 =# @inline viscosity(::FlavorOfTD, diffusivities) = begin
            #= none:322 =#
            diffusivities.κu
        end
#= none:323 =#
#= none:323 =# @inline (diffusivity(::FlavorOfTD, diffusivities, ::Val{id}) where id) = begin
            #= none:323 =#
            diffusivities._tupled_tracer_diffusivities[id]
        end
#= none:329 =#
function Base.summary(closure::TDVD)
    #= none:329 =#
    #= none:330 =#
    TD = nameof(typeof(time_discretization(closure)))
    #= none:331 =#
    return string("TKEDissipationVerticalDiffusivity{$(TD)}")
end
#= none:334 =#
function Base.show(io::IO, clo::TDVD)
    #= none:334 =#
    #= none:335 =#
    print(io, summary(clo))
    #= none:336 =#
    print(io, '\n')
    #= none:337 =#
    print(io, "├── maximum_tracer_diffusivity: ", prettysummary(clo.maximum_tracer_diffusivity), '\n', "├── maximum_tke_diffusivity: ", prettysummary(clo.maximum_tke_diffusivity), '\n', "├── maximum_dissipation_diffusivity: ", prettysummary(clo.maximum_dissipation_diffusivity), '\n', "├── maximum_viscosity: ", prettysummary(clo.maximum_viscosity), '\n', "├── minimum_tke: ", prettysummary(clo.minimum_tke), '\n', "├── negative_tke_damping_time_scale: ", prettysummary(clo.negative_tke_damping_time_scale), '\n', "├── tke_dissipation_time_step: ", prettysummary(clo.tke_dissipation_time_step), '\n', "├── tke_dissipation_equations: ", prettysummary(clo.tke_dissipation_equations), '\n', "│   ├── Cᵋϵ: ", prettysummary(clo.tke_dissipation_equations.Cᵋϵ), '\n', "│   ├── Cᴾϵ: ", prettysummary(clo.tke_dissipation_equations.Cᴾϵ), '\n', "│   ├── Cᵇϵ: ", prettysummary(clo.tke_dissipation_equations.Cᵇϵ), '\n', "│   ├── Cᵂu★: ", prettysummary(clo.tke_dissipation_equations.Cᵂu★), '\n', "│   └── CᵂwΔ: ", prettysummary(clo.tke_dissipation_equations.CᵂwΔ), '\n')
    #= none:350 =#
    print(io, "└── ", summarize_stability_functions(clo.stability_functions), "", "    ")
end